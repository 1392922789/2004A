##### 1.javascript的原型与原项链

```
一.原型
1.每个函数都有一个prototype属性，被称为显示原型
2.每个实例对象都会有__ptoto__属性，被称为隐式原型
3.每一个实例对象的隐式原型__proto__属性指向自身构造函数的显示原型prototype
4.每一个prototype原型都有一个constructor属性，指向它关联的构造函数
二.原型链
获取对象属性时，如果对象本身没有这个属性，那就会去他的原型__proto__上去找，如果还查不到，就去找原型的原型，一直找到最顶层(Object.prototype)为止。Object.prototype对象也有__proto__属性值为null。
Object是属于原型链的顶层，所有构造函数的prototype都指向Object.prototype
```

![img](https://img2018.cnblogs.com/blog/971833/201911/971833-20191108170310055-344774514.png)

##### 2..堆和栈的理解

```
为了更好的来阐述栈和堆，我们先来了解一下数据类型
基本数据类型：Number Boolean string undefined Null Symbol BigInt ，这几种种基本数据类型它们是直接按值存放的，所以可以直接访问。
引用数据类型：object Array Function我们需要访问这三种引用类型的值时，首先得从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据

栈(stack):由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；
堆(heap)：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。
```

##### 3.基本数据类型和引用数据类型

```
基本数据类型（简单）
null、undefined、boolean、string、number、Symbol
引用数据类型（复杂）：
Object含object Array Function Data
```

##### 4.数据类型检测的几种方式

```
Typeof：对于基本数据类型判断是没有问题的 但遇到引用数据类型是不起作用
instanceof：它用来判断这个构造函数的原型是否在给定对象的原型链上
constructor:constructor属性返回对象的构造函数,返回值是函数引用,而不是函数名
```

##### 5.语句

```
if swith for while for...in for...of
```

##### 6.运算符

```
== === += -= *= /= + / * % ++ - -- try catch
```

##### 7.作用域，作用域链

```
作用域分为：全局作用域 函数作用域 块级作用域
js中首先有一个最外层的作用域，全局作用域；
js中可以通过函数来创建一个独立作用域称为函数作用域，
函数可以嵌套，所以作用域也可以嵌套；
es6中新增了块级作用域（大括号，比如：if{},for(){},while(){}…）
2.作用域链
在函数内部访问一个变量，优先在当前函数内部查找，如果找到了就使用该变量，如果找不到则继续向父级查找，最后找到window顶层对象，如果还没有找到，则提示报错，这种由内向外查找的链条关系我们称为作用域链
	     
```

##### 8.this的指向

```
函数的不同调用方式决定this的指向不同
1.普通的函数this 指向window
2.对象的方法this指向当前的对象
3.绑定事件函数 this当前操作的Dom元素(对象)
4.定时器函数 this指向window
5.立即执行函数this也是指向window
```

##### 9.预编译

```
1.创建AO对象
2.形参和变量名统一，赋值undefined
3.实参和形参统一
4.申明式函数提升
5.表达式执行到哪一步就赋值
```

##### 10.递归

```
递：出去 归：回来
一直反复调用，必须有终止的条件，否则会陷入死循环
```

##### 11.严格模式

```js
严格模式，写在哪个作用域下，在那个作用域生效(尽量不要全局使用),使用后代码更加规范、更合理、更安全、更严谨。
    "use strict" 
    严格模式消除了js语法的一些不合理、不严谨之处、减少了怪异行为；消除了代码运行的不安全之处；提高编译器效率，提高运行速度；为未来新版本js做好铺垫
    用了严格模式，代码的变化：
    1.全局变量 必须用var声明变量
    2.this无法指向全局对象
    3.函数内重名属性(形参名字不能相同)
    4.arguments不允许动态修改，在严格模式下，argument保证了它的本质功能（arguments只存储在实际调用函数时实际传入的参数）
    5.新增保留字：impletents interface let package private protected public static yield
```

##### 12.闭包

```
 1. 闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过外部函数访问这个函数的内部的变量。闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。
  2. 不适合场景：返回闭包的函数是个非常大的函数。
    闭包的典型框架应该就是jquery了。
    闭包是javascript语言的一大特点，主要应用闭包场合主要是为了：设计私有的方法和变量。
    这在做框架的时候体现更明显，有些方法和属性只是运算逻辑过程中的使用的，不想让外部修改这些属性，因此就可以设计一个闭包来只提供方法获取。
  3. 不必纠结到底怎样才算闭包，其实你写的每一个函数都算作闭包，即使是全局函数，你访问函数外部的全局变量时，就是闭包的体现。
```

##### 13.解构赋值

```js
特性很强大，它可以帮我们从一堆嵌套很深的对象属性中，很方便地拿到我们想要的那一个
数组的解构赋值：
let a, b, rest;
[a, b] = [10, 20];
console.log(a);
// expected output: 10
console.log(b);
// expected output: 20
[a, b, ...rest] = [10, 20, 30, 40, 50];
console.log(rest);
// expected output: Array [30,40,50]
对象的解构赋值：
({ a, b } = { a: 10, b: 20 });
console.log(a); // 10
console.log(b); // 20
({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});
console.log(a); // 10
console.log(b); // 20
console.log(rest); // {c: 30, d: 40}
常规用法：
使用解构赋值经常使用到默认值的赋值，和使用 function的默认参数一样，使用 = 来添加属性的默认值
let a, b;
[a=5, b=7] = [1];
console.log(a); // 1
console.log(b); // 7
let {a = 10, b = 5} = {a: 3};
console.log(a); // 3
console.log(b); // 
```

##### 14.计时器

```
setInterval()每隔一段延迟时间，就会去调用回调函数，会持续的去调用
setTimeout()是延迟时间到了之后，就回去回调函数，只会调用一次，就结束这个定时器
setimmediate 在循环事件任务完成后马上运行指定代码和setTimeout差不多
```

#### 15.call apply bind

```
call,apply 会自动执行函数，bind不会自动执行需要手动执行
call方法 传递的参数是以参数列表的形式传递
apply 传递参数是以数组的形式传递
```

##### 16.递归

```
1)声明一个具名函数，通过函数名调用
2)使用arguments.callee代替函数名
3)使用函数表达式
```

##### 



