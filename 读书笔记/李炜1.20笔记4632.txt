时间data:

创建方法let now = new Date();



toDateString() 显示日期中的周几、月、日、年（格式特定于实

现）；

toTimeString() 显示日期中的时、分、秒和时区（格式特定于实

现）；

toLocaleDateString() 显示日期中的周几、月、日、年（格式特

定于实现和地区）；

toLocaleTimeString() 显示日期中的时、分、秒（格式特定于实

现）；

toUTCString() 显示完整的UTC日期（格式特定于实现）





getTime()返回日期的毫秒表示；与valueOf() 相同

setTime(*milliseconds*)设置日期的毫秒表示，从而修改整个日期

getFullYear()返回4位数年（即2019而不是19） 

getUTCFullYear()返回UTC日期的4位数年

setFullYear(*year*)设置日期的年（ *year* 必须是4位数）

setUTCFullYear(*year*)设置UTC日期的年（ *year* 必须是4位数）

getMonth()返回日期的月（0表示1月，11表 示12月）

getUTCMonth()返回UTC日期的月（0表示1月，11表示12月）



setMonth(*month*)设置日期的月（ *month* 为大于0的数值，大于11加年）

setUTCMonth(*month*)设置UTC日期的月（ *month* 为大于0的数值，大于11加年）

getDate()返回日期中的日（1~31） 

getUTCDate()返回UTC日期中的日（1~31） 

setDate(*date*)设置日期中的日（如果 *date* 大于该月天数，则加月）

setUTCDate(*date*)设置UTC日期中的日（如果date大于该月天数，则加月）

getDay()返回日期中表示周几的数值（0表示周日，6表示周六）





getUTCDay()返回UTC日期中表示周几的数值（0表示周日，6表示周六）

getHours()返回日期中的时（0~23） 

getUTCHours()返回UTC日期中的时（0~23） 

setHours(*hours*)设置日期中的时（如果 *hours*大于23，则加日）

setUTCHours(*hours*)设置UTC日期中的时（如果hours大于23，则加日）

getMinutes()返回日期中的分（0~59） 

getUTCMinutes()返回UTC日期中的分（0~59） 

setMinutes(*minutes*)设置日期中的分（如果minutes 大于59，则加时）

setUTCMinutes(*minutes*)设置UTC日期中的分（如果minutes大于59，则加时）





getSeconds()返回日期中的秒（0~59） 

getUTCSeconds()返回UTC日期中的秒（0~59） 

setSeconds(*seconds*)设置日期中的秒（如果seconds 大于59，则加分）

setUTCSeconds(*seconds*)设置UTC日期中的秒（如果seconds 大于59，则加分）

getMilliseconds()返回日期中的毫秒

getUTCMilliseconds()返回UTC日期中的毫秒

setMilliseconds(*milliseconds*)设置日期中的毫秒

setUTCMilliseconds(*milliseconds*)设置中的毫秒 UTC日期

getTimezoneOffset()返回以分钟计的UTC与本地时区的偏移量（如美国EST即“东部标准时间”返回300，进入夏令时的地区可能有所差异）





大多数引用值使用的Object类型，Object是最常用的类型之一。

显式地创建 Object 的实例有两种方式。第一种是使用 new 操作符和 Object 构造函数，如下所示：

let person = new Object(); 

person.name = "Nicholas"; 

person.age = 29;

还有一种是对象字面量表示法：

let arr={name:'asdf',age:20};

实际开发中更倾向对象字面量表示法。

function displayInfo(args) { 

let output = ""; 

if (typeof args.name == "string"){ 

output += "Name: " + args.name + "\n"; 

}

if (typeof args.age == "number") { 

output += "Age: " + args.age + "\n"; 

}

alert(output); 

}

displayInfo({ 

name: "Nicholas", 

age: 29 

}); 

displayInfo({ 

name: "Greg" 

});

创建数组：

let arr=new Array();

当在构造函数传入一个数值，会创建一个length为你传入的数值的数值

let arr=new Array(10);

let colors = new Array(3); *//* *创建一个包含**3**个元素的*数组*

let names = new Array("Greg"); *//* *创建一个只包含一个元*素，即字符串**"Greg"**的数组*

在使用 Array 构造函数时，也可以省略 new 操作符。结果是一样

的，比如：

let colors = Array(3); *//* *创建一个包含**3**个元素的数组*

let names = Array("Greg"); *//* *创建一个只包含一个元素，即*

*字符串**"Greg"**的数组*

另一种创建数组的方式是使用数组字面量（array literal）表示法。数

组字面量是在中括号中包含以逗号分隔的元素列表，如下面的例子所示：

let colors = ["red", "blue", "green"]; *//* *创建一个包*含**3**个元素的数组*

let names = []; *//* *创建一个空*数组*

let values = [1,2,]; *//* *创建一个包**含**2**个元素的数组*





ECMAScript 6新增的 Set 是一种新集合类型，为这门语言带来集合数据结构。 Set 在很多方面都像是加强的 Map ，这是因为它们的大多数API和行为都是共有的。

const m = new Set()

*//* *使用数组初始化集合*

const s1 = new Set(["val1", "val2", "val3"]); 

alert(s1.size); *// 3* 

*//* *使用自定义迭代器初始化集合* 

const s2 = new Set({ 

[Symbol.iterator]: function*() { 

yield "val1"; 

yield "val2"; 

yield "val3"; 

} 

}); 

alert(s2.size); *// 3*



初始化之后，可以使用 add() 增加值，使用 has() 查询，通过

size 取得元素数量，以及使用 delete() 和 clear() 删除元素：

const s = new Set(); 

alert(s.has("Matt")); *// false* 

alert(s.size); *// 0* 

s.add("Matt") 

.add("Frisbie"); 

alert(s.has("Matt")); *// true* 

alert(s.size); *// 2* 

s.delete("Matt");alert(s.has("Matt")); *// false* 

alert(s.has("Frisbie")); *// true* 

alert(s.size); *// 1* 

s.clear(); *//* *销毁集合实例中的所有值*

alert(s.has("Matt")); *// false* 

alert(s.has("Frisbie")); *// false* 

alert(s.size); *// 0* 

add() 返回集合的实例，所以可以将多个添加操作连缀起来，包括

初始化：

const s = new Set().add("val1"); 

s.add("val2") 

.add("val3"); 

alert(s.size); *// 3* 

与 Map 类似， Set 可以包含任何JavaScript数据类型作为值。集合也

使用SameValueZero操作（ECMAScript内部定义，无法在语言中使用），

基本上相当于使用严格对象相等的标准来检查值的匹配性。

const s = new Set(); 

const functionVal = function() {}; 

const symbolVal = Symbol(); 

const objectVal = new Object();s.add(functionVal); 

s.add(symbolVal); 

s.add(objectVal); 

alert(s.has(functionVal)); *// true* 

alert(s.has(symbolVal)); *// true* 

alert(s.has(objectVal)); *// true* 

*// SameValueZero**检查意味着独立的实例不会冲突*

alert(s.has(function() {})); *// false*

与严格相等一样，用作值的对象和其他“集合”类型在自己的内容或属

性被修改时也不会改变：

const s = new Set(); 

const objVal = {}, 

arrVal = []; 

s.add(objVal); 

s.add(arrVal); 

objVal.bar = "bar"; 

arrVal.push("bar"); 

alert(s.has(objVal)); *// true* 

alert(s.has(arrVal)); *// true* 

add() 和 delete() 操作是幂等的。 delete() 返回一个布尔

值，表示集合中是否存在要删除的值：const s = new Set(); 

s.add('foo'); 

alert(s.size); *// 1* 

s.add('foo'); 

alert(s.size); *// 1* 

*//* *集合里有这个值*

alert(s.delete('foo')); *// true* 

*//* *集合里没有这个值*

alert(s.delete('foo')); *// false* 