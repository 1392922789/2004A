# 								**什么是  Javascript  ？**

### 1、 关键字保留字

```
  CMA-262描述了一组保留的关键字，这些关键字有特殊用途，
     比如表示控制语句的开始和结束，或者执行特定的操作。按照规定，
     保留的关键字不能用作标识符或属性名
      break do in typeof case else instanceof var  catch  export  new ......
```

### 2、 var    let  const 区别

```
 使用var时，这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部
   let跟var的作用差不多，但有着非常重要的区别。最明显的区别是，let声明的范围是块作用域，而var声明的范围是函数作用域，let与var的另一个重要的区别，
就是let声明的变量不会在作用域中被提升在let出现之前，for循环定义的迭代变量会渗透到循环体外，改成使用let之后，这个问题就消失了，因为迭代变量的作
用域仅限于for循环块内部
    const的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误。const声明的限制
只适用于它指向的变量的引用。换句话说， 如果const变量引用的是一个对象，那么修改这个对象内部的属性并不违反const的限制。
```

### 3、  数据类型

```
 ECMAScript有6种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String和Symbol。Symbol（符号）是ECMAScript 6新增的。
还有一种复杂数据类型叫Object（对象）。Object是一种无序名值对的集合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之
一来表示。只有7种数据类型似乎不足以表示全部数据。但ECMAScript的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。
```

### 4、  基本数据类型详解

```
   ①  typeof 对于基本数据类型判断是没有问题的，但是遇到引用数据类型（如：Array）是不起作用
   ②  Undefined类型只有一个值，就是特殊值undefined。当使用var或let声明了变量但没有初始化时，就相当于给变量赋予了undefined值。
   ③  Null类型同样只有一个值，即特殊值null。逻辑上讲，null值表示一个空对象指针，这也是给typeof传一个null会返回"object"的原因。
   ③  Boolean（布尔值）类型是ECMAScript中使用最频繁的类型之一，有两个字面值：true和false
   ⑤  string字符串是不可变的，意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量转换字符串方法 toString和string函数两种方法。
   ⑥  Symbol（符号）是ECMAScript 6新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。Symbol.hasInstance   Symbol.isConcatSpreadable   Symbol.iterator
Symbol.match     Symbol.replace   Symbol.search  Symbol.species   Symbol.split  Symbol.toPrimitive   Symbol.toStringTag   Symbol.unscopables
```

### 5、Object类型

```
  ECMAScript中的对象其实就是一组数据和功能的集合。对象通过new操作符后跟对象类型的名称来创建。开发者可以通过创建Object类型的实例来创建自己的对象，然后再给
对象添加属性和方法
   object的实例本身并不是很有用，但理解与它相关的概念非常重要。类似Java中的java.lang.Object，ECMAScript中的Object也是派生其他对象的基类。Object类型的所有属性和方法在派生的对象上同样存在
```

### 6、 操作符

```
 一元操作符   位操作符（不太明白） 布尔操作符（逻辑与和逻辑或）  乘性操作符   指数操作符   加性操作符   关系操作符   相等操作符   条件操作符   赋值操作符  逗号操作符
```

### 7、语句

- if语句是使用最频繁的语句之一
- do-while语句
- while语句     
- for语句    
- for-in语句     
- for-of语句     
- 标签语句      
- break和continue语句    
- with语句     
- switch语句

### 8、函数

```
函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。要注意的是，只要碰到return语句，函数就会立即停止执行并退出。
```

### 9、原始值与引用值

ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（referencevalue）则是由多个值构成的对象。

- ```
  -  	原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法。
  - 除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。
  - 在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个
    变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来
  ```

### 10、确定类型

```
  typeof操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或undefined的最好方式。如果值是对象或null，那么typeof返回"object"
     所有引用值都是Object的实例，因此通过instanceof操作符检测任何引用值和Object构造函数都会返回true。类似地，如果用instanceof检测原始值，则始终会返回false，因为原始值不是对象。
```

### 11、执行上下文与作用域

- ```
  	  		执行上下文（以下简称“上下文”）的概念在JavaScript中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object）而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。
  				每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。					ECMAScript程序的执行流就是通过这个上下文栈进行控制的上下文中的代码在执行的时候，会创建变量对象的一个作用（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。
  				如果上下文是函数，则其活动对象（activationobject）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象函数changeColor()的作用域链包含两个对象：一个是它自己的变量对象（就是定义arguments对象的那个），另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量color，就是因为可以在作用域链中找到它
  ```

  

### 12、变量声明

```
 ECMAScript 5.1，var都是声明变量的唯一关键字。ES6不仅增加了let和const两个关键字，而且还让这两个关键字压倒性地超越var成为首选
```

- #### var：

  ```
  在使用var声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文
  ```

- #### let：

  ```
     let关键字跟var很相似，但它的作用域是块级的，这也是JavaScript中的新概念。块级作用域由最近的一对包含花括号{}界定。换句话说，if块、while块、function块，甚至连单独的块也是let声明变量的作用域。
      let与var的另一个不同之处是在同一作用域内不能声明两次。重复的var声明会被忽略，而重复的let声明会抛
  ```

- #### const：

  ```
   ES6同时还增加了const关键字。使用const声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。const声明只应用到顶级原语或者对象。换句话说，赋值为对象的const变量不能再被重新赋值为其他引用值，但对象的键则不受限制
  ```

### 13、垃圾回收

JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在C和C++等语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源

#####  1 标记清理

```
JavaScript最常用的垃圾回收策略是标记清理（mark-andsweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。
     而不在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。
```

#####  2 引用计数

```
另一种没那么常用的垃圾回收策略是引用计数（referencecounting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。
   如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问
   到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存
```

### 14、 性能

```
 	垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。
 			开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作由于调度垃圾回收程序方面的问题会导致性能下降，IE曾饱受诟病。
 				它的策略是根据分配数，比如分配了256个变量、4096个对象/数组字面量和数组槽位（slot），或者64KB字符串只要满足其中某个条件，垃圾回收程序就会运行。这样实现的问题在于，分配那么多变量的脚本，很可能在其整个生命周期内始终需要那么多变量，结果就会导致垃圾回收程序过于频繁地运行。
 					由于对性能的严重影响，IE7最终更新了垃圾回收程序。
		IE7发布后，JavaScript引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值。IE7的起始阈值都与IE6的相同。如果垃圾回收程序回收的内存不到已分配的15%，这些变量、字面量或数组槽位的阈值就会翻倍。如果有一次回收的内存达到已分配的85%，则阈值重置为默认值。
		这么一个简单的修改，极大地提升了重度依赖JavaScript的网页在浏览器中的性能
```

### 15 、内存管理

```
在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。不过，JavaScript运行在一个内存管理与垃圾回收都很特殊的环境。分配给浏览器的内存通常比分配给桌面软件的要少很多分配给移动浏览器的就更少了。这更多出于安全考虑而不是别的，就是为了避免运行大量JavaScript的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量
```

### 16、 小结

```
   原始值大小固定，因此保存在栈内存上。从一个变量到另一个变量复制原始值会创建该值的第二个副本。
     引用值是对象，存储在堆内存上。包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。从一个变量到另一个变量复制引用值只会复制指针，
因此结果是两个变量都指向同一个对象。typeof操作符可以确定值的原始类型，而instanceof操作符用于确保值的引用类型。
     任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分
```

#                            **第六章     集合引用类型**

###  1、 <u>对象Object</u>

​     对象被认为是某个特定引用类型的实例。新对象通过使用new操作符后跟一个构造函数（constructor）来创建。构造函数就是用来创建新对象的函数
​     Date类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间1970年1月1日午夜（零时）至今所经过的毫秒数。使用这种存储格式，
Date类型可以精确表示1970年1月1日之前及之后285 616年的日期。 要创建日期对象，就使用new操作符来调用Date构造函数

    比如，要创建一个表示“2019年5月23日”的日期对象，可以使用以下代码：letsomeDate=newDate(Date.parse("May23,2019"));如果传给Date.parse()的
字符串并不表示日期，则该方法会返回NaN。如果直接把表示日期的字符串传给Date构造函数，那么Date会在后台调用Date.parse()

### 2、<u>继承方法</u>

   Date类型重写了toLocaleString()、toString()和valueOf()方法。但与其他类型不同，重写后这些方法的返回值不一样。Date类型的toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的AM（上午）或PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。

toString()方法通常返回带时区信息的日期和时间，而时间也是以24小时制（0~23）表示的。下面给出了toLocaleString()和toString()返回的2019年2月1
日零点的示例（地区为"en-US"的PST，即Pacific Standard Time，太平洋标准时间）

    例如
     let data= new Date()
    console.log(data.toLocaleString()) //   2021/1/20 下午8:46:23
    console.log(data.toLocaleDateString())  //   2021/1/20
    console.log(data.toLocaleTimeString())   //下午8:52:54
    console.log(data.toUTCString())    //Wed, 20 Jan 2021 12:54:18 GMT

### 3、 日期格式化方法

```
  Date类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC日期”，指的是没有时区偏移（将日期转换为GMT）时的日期。
```

### 4、 <u>RegExp（正则）</u>

```
 ECMAScript通过RegExp类型支持正则表达式。
```

- g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。
- i：不区分大小写，表示在查找匹配时忽略pattern和字符串的大小写。
- m：多行模式，表示查找到一行文本末尾时会继续查找。
- y：粘附模式，表示只查找从lastIndex开始及之后的字符串。
- u：Unicode模式，启用Unicode匹配。
- s：dotAll模式，表示元字符.匹配任何字符（包括\n或\r）

### 5、   RegExp实例属性

```
每个RegExp实例都有下列属性，提供有关模式的各方面信息。
```

-  global：布尔值，表示是否设置了g标记。ignoreCase：布尔值，表示是否设置了i标记。
- unicode：布尔值，表示是否设置了u标记。sticky：布尔值，表示是否设置了y标记。
-  lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。
- multiline：布尔值，表示是否设置了m标记。dotAll：布尔值，表示是否设置了s标记。
- source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。
- flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。

### 6、  RegExp构造函数属性

```
  RegExp构造函数本身也有几个属性。（在其他语言中，这种属性被称为静态属性。）这些属性适用于作用域
中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过两
种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。
```

### 7、 模式局限

```
虽然ECMAScript对正则表达式的支持有了长足的进步，但仍然缺少Perl语言中的一些高级特性。
```

### 8、 原始值包装类型

```
   为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：Boolean、Number和String。
这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。
每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法
```

### 9、 <u>Boolean</u>

- ```
  	- Boolean是对应布尔值的引用类型。要创建一个Boolean对象，就使用Boolean构造函数并传入true或false，
  	我们创建一个值为false的Boolean对象。然后，在一个布尔表达式中通过&&操作将这个对象与一个原始值true组合起来。
  	- 在布尔算术中，false&&true等于false。可是，这个表达式是对falseObject对象而不是对它表示的值（false）求值。前面刚刚说过，所有对象在布尔表达式中都会自动转换为true，因此falseObject在这个表达式里实际上表示一个true值。那么true&&true当然是true。
  	- 原始值和引用值（Boolean对象）还有几个区别。首先，typeof操作符对原始值返回"boolean"，但对引用值返回"object"。同样，Boolean对象是Boolean类型的实例，在使用instaceof操作符时返回true，但对原始值则返回false
  ```

### 10、 <u>Number</u>

```
 		Number是对应数值的引用类型。要创建一个Number对象，就使用Number构造函数并传入一个数值与Boolean类型一样，Number类型重写了valueOf()、toLocaleString()和toString()方法。
 		valueOf()方法返回Number对象表示的原始数值另外两个方法返回数值字符串。
 		toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串除了继承的方法，Number类型还提供了几个用于将数值格式化为字符串的方法。
```

```
toFixed()方法返回包含指定小数点位数的数值字符串
   这里的toFixed()方法接收了参数2，表示返回的数值字符串要包含两位小数。结果返回值为"10.00"，小数位填充了0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位
   letnum=10.005;   console.log(num.toFixed(2));//"10.01"
   原始数值在调用typeof时始终返回"number"，而Number对象则返回"object"。类似地，Number对象是Number类型的实例，而原始数值不是
    isInteger()方法与安全整数
   ES6新增了Number.isInteger()方法，用于辨别一个数值是否保存为整数。有时候，小数位的0可能会让人误以为数值是一个浮点值
```

### 11、  <u>String</u>

```
String是对应字符串的引用类型。要创建一个String对象，使用String构造函数并传入一个数值
  		String对象的方法可以在所有字符串原始值上调用。3个继承的方法valueOf()、toLcaleString()和toString()都返回对象的原始字符串值。
每个String对象都有一个length属性，表示字符串中字符的数量。
```

### 12、  字符串操作方法

```
 	concat()，用于将一个或多个字符串拼接成一个新字符串，虽然concat()方法可以拼接字符串，但更常用的方式是使用加号操作符（+）。而且多数情况下，对于拼接多个字符串来说，使用加号更方便。
   	slice()、substr()和substring()。这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。对slice()和substring()而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来）。
   	对substr()而言，第二个参数表示返回的子字符串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾。
```

### 13、 字符串位置方法

```
有两个方法用于在字符串中定位子字符串：indexOf()和lastIndexOf()。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）。两者的区别在于，
indexOf()方法从字符串开头开始查找子字符串，而lastIndexOf()方法从字符串末尾开始查找子字符串

   如果字符串中只有一个"o"，则indexOf()和lastIndexOf()返回同一个位置。这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。这意味着，indexOf()会从这个
参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；lastIndexOf()则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符
 let stringValue="helloworld";   console.log(stringValue.indexOf("o"));//4       console.log(stringValue.lastIndexOf("o"));//7


   在传入第二个参数6以后，结果跟前面的例子恰好相反。这一次，indexOf()返回7，因为它从位置6（字符"w"）开始向后搜索字符串，在位置7找到了"o"。而lastIndexOf()返回4
，因为它从位置6开始反向搜索至字符串开头，因此找到了"hello"中的"o"。像这样使用第二个参数并循环调用indexOf()或lastIndexOf()，就可以在字符串中找到所有的目标子字符串
letstringValue="helloworld";console.log(stringValue.indexOf("o",6));//7console.log(stringValue.lastIndexOf("o",6));//4
```

​    

### 14、 字符串包含方法

   ECMAScript 6增加了3个用于判断字符串中是否包含另一个字符串的方法：startsWith()、endsWith()和includes()。

这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。它们的区别在于，startsWith()检查开始于索引0的匹配项，endsWith()检查开始于索引(string.length-substring.length)的匹配项，而includes()检查整个字符串

- ```
  			-   startsWith()和includes()方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符
  			- endsWith()方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样
  - trim()方法
      CMAScript在所有字符串上都提供了trim()方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果
  -  repeat()方法
      ECMAScript在所有字符串上都提供了repeat()方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果
    -  padStart()和padEnd()方法
        padStart()和padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格
  ```

### 15、 字符串大小写转换

```
下一组方法涉及大小写转换，包括4个方法：
	toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。
toLowerCase()和toUpperCase()方法是原来就有的方法，与java.lang.String中的方法同名。
	toLocaleLowerCase()和toLocaleUpperCase()方法旨在基于特定地区实现。在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳其语），Unicode大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。
```

### 16、字符串模式匹配方法

```
  	match()方法返回的数组与RegExp对象的exec()方法返回的数组是一样的：第一个元素是与整个模式匹配的字符串，其余元素则是与表达式中的捕获组匹配的字符串（如果有的话）。
  	另一个查找模式的字符串方法是search()。这个方法唯一的参数与match()方法一样：正则表达式字符串或RegExp对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。
  	search()始终从字符串开头向后匹配模式
```

### 17、 <u>Object</u>

```
  	 到目前为止，大多数引用值的示例使用的是Object类型。Object是ECMAScript中最常用的类型之一。虽然Object的实例没有多少功能，但很适合存储和在应用程序间交换数据。显式地创建Object的实例有两种方式。
   第一种是使用new操作符和Object构造函数，
   另一种方式是使用对象字面量（object literal）
```

### 18、<u>Array</u>

   创建数组几种方式:

   1  使用Array构造函数

```
创建数组时可以给构造函数传一个值。这时候就有点问题了，因为如果这个值是数值，则会创建一个长度为指定数值的数组；而如果这个值是其他类型的，则会创建一个只包含该特定值的数组
```

   2 另一种创建数组的方式是使用数组字面量（array literal）表示法。数组字面量是在中括号中包含以逗号分隔的元素列表

```
		Array构造函数还有两个ES6新增的用于创建数组的静态方法：from()和of()。from()用于将类数组结构转换为数组实例，而of()用于将一组参数转换为数组实例
   Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个length属性和可索引元素的结构
   Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用Array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数
中this的值。但这个重写的this值在箭头函数中不适用 
   Array.of()可以把一组参数转换为数组。这个方法用于替代在ES6之前常用的Array.prototype.slice.call(arguments)，一种异常笨拙的将arguments对象转换为数组的写法
```



### 19、数组索引

```
要取得或设置数组的值，需要使用中括号并提供相应值的数字索引
  length设置为大于数组元素数的值，则新添加的元素都将以undefined填充
```

### 20、 检测数组

```
一个经典的ECMAScript问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用instanceof操作符就足矣。
   		使用instanceof的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的Array构造函数。
		 	有对象都有toLocaleString()、toString()和valueOf()方法。其中，valueOf()返回的还是数组本身。而toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，
对数组的每个值都会调用其toString()方法，以得到最终的字符串
  		toLocaleString()方法也可能返回跟toString()和valueOf()相同的结果，但也不一定。在调用数组的toLocaleString()方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法唯一的区别是，
为了得到最终的字符串，会调用数组每个值的toLocaleString()方法，而不是toString()方法
```

### 21、 数组排序

```
数组有两个方法可以用来对元素重新排序：reverse()和sort()。
  	顾名思义，reverse()方法就是将数组元素反向排列在给sort()方法传入比较函数后，数组中的数值在排序后保持了正确的顺序。
  		slice()用于创建一个包含原有数组中一个或多个元素的新数组。slice()方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则slice()会返回该索引到数组末尾的所有元素。
如果有两个参数，则slice()返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。记住，这个操作不影响原始数组
  		splice()的主要目的是在数组中间插入元素，但有3种不同的方式使用这个方法删除。需要给splice()传2个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，比如splice(0,2)会删除前两个元素。插入。需要给splice()传3个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如，splice(2,0,"red","green")会从数组位置2开始插入字符串"red"和"green"。
  替换。splice()在删除元素的同时可以在指定位置插入新元素，同样要传入3个参数：开始位置、要删除元素的数量和要插入的任意
```

### 22、 搜索和位置方法

```
  		ECMAScript提供了3个严格相等的搜索方法：indexOf()、lastIndexOf()和includes()。其中，前两个方法在所有版本中都可用，而第三个方法是ECMAScript 7新增的。
  		这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。indexOf()和includes()方法从数组前头第一项）开始向后搜索，而lastIndexOf()从数组末尾（最后一项）开始向前搜索。
  		indexOf()和lastIndexOf()都返回要查找的元素在数组中的位置，如果没找到则返回-1。includes()返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（===）比较，也就是说两项必须严格相等

  ind()和findIndex()方法使用了断言函数。这两个方法都从数组的最小索引开始。find()返回第一个匹配的元素，findIndex()返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部this的值。
```

### 23、定型数组

```
	Array实际上是一种“视图”，可以允许JavaScript运行时访问一块名为ArrayBuffer的预分配内存。ArrayBuffer是所有定型数组及视图引用的基本单位。
  		定型数组是另一种形式的ArrayBuffer视图。虽然概念上与DataView接近，但定型数组的区别在于，它特定于一种ElementType且遵循系统原生的字节序。
  		相应地，定型数组提供了适用面更广的API和更高的性能。设计定型数组的目的就是提高与WebGL等原生库交换二进制数据的效率。由于定型数组的二进制表示对操作系统而言是一种容易使用的格式，JavaScript引擎可以重度优化算术运算、按位运算和其他对定型数组的常见操作，因此使用它们速度极快创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。
```

-   定型数组与普通数组都很相似。定型数组支持如下操作符、方法和属性：

  copyWithin()  entries()   every() fill() filter() find() findIndex() forEach() indexOf() join() keys() lastIndexOf() lengthmap() reduce() reduceRight() reverse() slice() some() sort() toLocaleString() toString()values()

### 24、合并、复制和修改定型数组

```
定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小
```

### 25、 <u>Map</u>

```
  ECMAScript 6以前，在JavaScript中实现“键/值”式存储可以使用Object来方便高效地完成，也就是使用对象属性作为键，再使用属性来引用值。但这种实现并非没有问题，为此TC39委员会专门为“键/值”存储定义了一个规范。
  		作为ECMAScript 6的新增特性，Map是一种新的集合类型，为这门语言带来了真正的键/值存储机制。Map的大多数特性都可以通过Object类型实现，但二者之间还是存在一些细微的差异。具体实践中使用哪一个，还是值得细细甄别。
			如果想在创建的同时初始化实例，可以给Map构造函数传入一个可迭代对象，需要包含键/值对数组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中初始化之后，可以使用set()方法再添加键/值对。另外，可以使用get()和has()进行查询，可以通过size属性获取映射中的键/值对的数量，还可以使用delete()和clear()删除值。
```

### 26、Map与Object类型的主要差异

```
 		Map与Object类型的一个主要差异是，Map实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。映射实例可以提供一个迭代器（Iterator），能以插入顺序生成[key,value]形式的数组。
 		可以通过entries()方法（或者Symbol.iterator属性，它引用entries()）取得这个迭代器
```

### 27、基本API

```
弱映射中的键只能是Object或者继承自Object的类型，尝试使用非对象设置键会抛出TypeError。值的类型没有限制。如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对象，其中需要包含键/值对数组。
```

### 28、 弱键

```
 	 WeakMap中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。
  	只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收
```

### 29、 不可迭代键

```
  	因为WeakMap中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力。当然，也用不着像clear()这样一次性销毁所有键/值的方法。WeakMap确实没有这个方法。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱映射中取得值。
  	即便代码可以访问WeakMap实例，也没办法看到其中的内容。WeakMap实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了
```

### 30、定义正式集合操作

```
		从各方面来看，Set跟Map都很相似，只是API稍有调整。唯一需要强调的就是集合的API只支持自引用操作。很多开发者都喜欢使用Set操作，但需要手动实现：或者是子类化Set，或者是定义一个实用函数库。
		要把两种方式合二为一，可以在子类上实现静态方法，然后在实例方法中使用这些静态方法。
```

### 31、WeakSet

```
  ECMAScript 6新增的“弱集合”（WeakSet）是一种新的集合类型，为这门语言带来了集合数据结构。
  	WeakSet是Set的“兄弟”类型，其API也是Set的子集。WeakSet中的“weak”（弱），描述的是JavaScript垃圾回收程序对待“弱集合”中值的方式
```

### 32、弱值

```
WeakSet中“weak”表示弱集合的值是“弱弱地拿着”的。意思就是，这些值不属于正式的引用，不会阻止垃圾回收
```

### 33、不可迭代值

```
 		因为WeakSet中的值任何时候都可能被销毁，所以没必要提供迭代其值的能力。当然，也用不着像clear()这样一次性销毁所有值的方法。WeakSet确实没有这个方法。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱集合中取得值。即便代码可以访问WeakSet实例，也没办法看到其中的内容。
 		WeakSet之所以限制只能用对象作为值，是为了保证只有通过值对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了
```

### 34、迭代与扩展操作

```
  		ECMAScript 6新增的迭代器和扩展操作符对集合引用类型特别有用。这些新特性让集合类型之间相互操作、复制和修改变得异常方便。
  		这也意味着所有这些类型都兼容扩展操作符。扩展操作符在对可迭代对象执行浅复制时特别有用，只需简单的语法就可以复制整个对象
```

### 35、<u>小结</u>

```
    JavaScript中的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。引用类型与传统面向对象编程语言中的类相似，但实现不同。
    Object类型是一个基础类型，所有引用类型都从它继承了基本的行为。
    Array类型表示一组有序的值，并提供了操作和转换值的能力。定型数组包含一套不同的引用类型，用于管理数值在内存中的类型。Date类型提供了关于日期和时间的信息，包括当前日期和时间以及计算。
   RegExp类型是ECMAScript支持的正则表达式的接口，提供了大多数基本正则表达式以及一些高级正则表达式的能力。JavaScript比较独特的一点是，函数其实是Function类型的实例，这意味着函数也是对象。由于函数是对象，因此也就具有能够增强自身行为的方法。
```

